알고리즘: 문제를 해결하기 위한 단계적인 절차

알고리즘은 요리법과 유사: 단계적인 절차를 따라 해야함.

효율적인 알고리즘 고안이 중요: 주어진 문제에 대해 다양한 알고리즘이 있지만, 항상 보다 효율적인 알고리즘을 고안하는 것이 매우 중요

순차 탐색: 주어진 순서대로 읽어가며 찾는 방법. 시간 복잡도 (n)

동전 거스름돈: 동전들이 정수배로 커져야 greedy방식을 사용할 수 있다.
ex) 500,100,50,10

한붓그리기: 오일러서킷

현재 점으로 돌아오는 사이클이 있다면 진행
외길이면 사이클 체크없이 인접한 점으로 이동

미로 찾기: 오른손 법칙(되는 이유: 모든 벽이 다 연결 되어있다면 다 피면 한줄이 됨) 왼손도 가능

가짜 동전 찾기

최악과 최선이 엄청난 차이
하나씩 비교하기
2개씩 짝지어서 비교하기

최악과 최선이 비슷
절반으로 나눠서 비교하기 반복
3덩이로 나눠서 비교하기 반복

독이 든 술단지: 독이 어디있는가 몇명의 신하가 필요한가
3명으로 8개의 술단지 확인가능
즉 n명이면 2^n개 확인가능

이진 탐색: 정렬된 데이터에 대해 중간에 있는 데이터 비교 같으면 탐색 끝, 다르면 값의 크기에 따라 왼쪽 혹은 오른쪽으로 



특성

정확성:올바른 해를 주어야함
수행성:컴퓨터에서 수행가능해야함
유한성:유한 시간내에  끝나야함
효율성:효울적이여야함


유클리드의 최대공약수 알고리즘: 가장 오래된 알고리즘(기원전 300년경)
2개의 자연수의 최대공약수는 큰수에서 작은수를 뺀 수와 작은수의 최대 공약수와 같다.


알고리즘의 각 단계는 보통 말로 서술할 수 있음. 프로그래밍 언어로만 표현할 필요 없음.
일반적으로 알고리즘은 프로그래밍 언어와 유사한 의사 코드(pseudo code: 슈도 코드)로 표현
빨리쓰고 빨리 이해하기 위해서

flow chart: 개발자가 갑(요청한 사람)에게 이러한 방식으로 돌아가는 것을 보여주기 위해 쓰기도 함.


효율성: 수행시간 또는 수행하는 동안 사용되는 메모리 크키로 나타낼수 있음.(시간 복잡도, 공간 복잡도)
일반적으로 시간 복잡도가 주로 사용됨.

복잡도 표현 방법
1. 최악 경우 분석 - 상한의 의미
2. 평균 경우 분석 - 균등 분포를 가정
3. 최선 경우 분석 - 가장 빠른 수생 시간, 최적(optimal) 알고리즘 찾는데 활용
주로 최악의 경우를 씀.(qsort는 최악이 아닌 평균 경우로 생각함.)

점근적 표기 (중요)
big oh-점근적 상한
big omega-점근적 하한
theta - 둘다(동일한 증가율) (표기는 O로 함)

포함 관계: 상수 -> 로그->1차->2차->3차->2^n

내부 정렬 - 메모리에 다 올릴수 있음
외부 정렬 - 다 못 올림

알고리즘 시간 복잡도 표 중요(최선, 최악, 평균, stable 한지 안한지)
tim sort 를 많이 씀(알아보기)(안정적임)


시간 복잡도 n^2

버블 정렬 : 개발하기 편함, n^2중 가장 느림
선택 정렬 : n^2중에서 가장 빠름(임의의 데이터에서) , 입력에 민감하지 않은 알고리즘, 항상 일정한 시간 복잡도
삽입 정렬 : 정렬된 부분과 안된 부분으로 나누고, 안된 부분의 가장 왼쪽 원소를 정렬된 부분의 적절한 위치로 삽입하여 정렬
	  이미 정렬되어 있으면 시간 복잡도 n

조건에 따라서 삽입이 빠르기도 함.



쉘 정렬 : 사람이름에서 따옴. 어짜피 갈 녀석이면 빨리 보내자.
              간격(gap)을 이용. 버블과 삽입을 같이 이용
시간 복잡도: 대략 n^1.5 or n^0.75 라고 추측, 아직 풀리지 않는 문제
가장 좋은 성능을 보인 간격이 있는데 바뀔수 있음
입력 크기가 매우 크지 않는 경우 매우 좋은 성능
임베디드 시스템에서 주로 사용



힙 정렬: 힙 조건을 만족하는 완전 이진 트리일 때 가능
자식들이 힙 상태여야만 가능(그래서 밑에서 부터 함)
노드가 n개면 n/2만 자식이 있음. n/2부터 시작
힙 만드는데 n시간, downheap logn시간 = nlogn 시간복잡도 (무조건, 추가공간 필요x)
단, nlogn 중에서 제일 느림 (캐시 미스가 너무 많아서)

중요: 비교 정렬 문제의 하한은  오메가 (nlogn)

기수 정렬과 count 정렬은 특정 조건에서만 비교 정렬보다 빠름
비교 정렬은 어떤 조건이든 가능

logn! = nlogn

기수정렬 : 자릿수 별로 정렬




분할 정복: 주어진 문제의 입력을 분할하여문제를 해결(정복)하는 방식의 알고리즘
반씩 나눔

합병 정렬 3단계

왼쪽 절반 정렬
오른쪽 절반 정렬
합병한다

합병 정렬 공간 복잡도 n
시간복잡도  nlogn
대부분 정렬 알고리즘은 1 크기의 메모리 공간만을 사용



퀵 정렬 3단계

파티션으로 피벗 위치 확인
피벗의 왼쪽 정렬
피벗의 오른쪽 정렬


퀵 정렬은 문제를 2개의 부분 문제로 분할(완벽하게 절반으로 나누는게 아님)


비교횟수 n, 깊이 logn(최악 n)
최선 경우 시간 복잡도  nlogn
최악 경우 시간 복잡도 n^2

피벗 선정 방법 : 랜덤, median f median(크기가 클때)

퀵 정렬의 성능을 향상하기 위해 삽입 정렬을 동시에 사용


선택 문제
작은 그룹에 k번째 작은 숫자가 속한 경우
k번째 작은 숫자를 작은 그룹에서 찾는다.

큰 그룹에서 k번째로 작은 숫자가 있는 경우

k-작은그룹의 크기 - 1번째로 작은 숫자를 찾는다.



최근접 점의 쌍 찾기

반으로 쪼개서 각각 가장 가까운 점찾고 비교하기
반으로 나뉜 중간 영역도 고려해야함

시간 복잡도 nlogn


주의할 점

부적절한지 확인해야함
피보나치 수
취합할때도 주의해야함


입력 크기보다 커지는 경우 조심하기

















